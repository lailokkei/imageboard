package imageboard

import (
	"database/sql"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/jmoiron/sqlx"
)

type Thread struct {
	Id       int
	Title    string `form:"title"`
	Comment  string `form:"comment"`
	Time     string `db:"to_char"`
	Image_id string
}

type Reply struct {
	Id        int
	Thread_id int
	Comment   string `form:"comment"`
	Time      string `db:"to_char"`
	Image_id  sql.NullString
}

type Image struct {
	id   string
	name string
}

const imagesDir = "../../images/"

func ConnectToDB() *sqlx.DB {
	return sqlx.MustConnect("pgx", os.Getenv("DATABASE_URL"))
}

func InitSchema(db *sqlx.DB) {
	schema := `
        CREATE TABLE images(
            id uuid PRIMARY KEY,
            name varchar(255) NOT NULL
        );

        CREATE TABLE threads (
            id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            image_id uuid REFERENCES images(id) NOT NULL,
            title varchar(80) NOT NULL,
            comment varchar(2000) NOT NULL,
            time timestamp NOT NULL
        );

        CREATE TABLE replies(
            id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            thread_id integer REFERENCES threads(id) NOT NULL,
            image_id uuid REFERENCES images(id),
            comment varchar(2000) NOT NULL,
            time timestamp NOT NULL
        );
        `

	db.MustExec(schema)
}

func CreateThread(db *sqlx.DB, thread Thread, img *multipart.FileHeader) error {
	tx, err := db.Beginx()

	if err != nil {
		log.Println(err.Error())
		return err
	}

	imageId, err := CreateImage(tx, img)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	cmd := `INSERT INTO threads(title, comment, time, image_id) VALUES ($1,$2, CURRENT_TIMESTAMP, $3)`
	_, err = tx.Exec(cmd, thread.Title, thread.Comment, imageId)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	tx.Commit()

	return nil
}

func CreateImage(tx *sqlx.Tx, img *multipart.FileHeader) (string, error) {
	var uuid string
	row := tx.QueryRow(`SELECT gen_random_uuid()`)
	err := row.Scan(&uuid)
	if err != nil {
		return uuid, err
	}

	filePath := imagesDir + uuid
	srcFile, err := img.Open()
	if err != nil {
		return uuid, err
	}
	dstFile, err := os.Create(filePath)
	if err != nil {
		return uuid, err
	}
	defer srcFile.Close()
	defer dstFile.Close()
	io.Copy(dstFile, srcFile)

	_, err = tx.Exec(`INSERT INTO images(id, name) VALUES ($1, $2)`, uuid, img.Filename)
	if err != nil {
		return uuid, err
	}

	return uuid, nil
}

func CreateReply(db *sqlx.DB, reply Reply, img *multipart.FileHeader) error {
	tx, err := db.Beginx()
	if err != nil {
		tx.Rollback()
		return err
	}

	if img != nil {
		imageId, err := CreateImage(tx, img)
		if err != nil {
			tx.Rollback()
			return err
		}

		cmd := `INSERT INTO replies(thread_id, comment, time, image_id) VALUES ($1, $2, CURRENT_TIMESTAMP, $3)`
		res, err := tx.Exec(cmd, reply.Thread_id, reply.Comment, imageId)
		_ = res
		if err != nil {
			log.Println(err)
		}

		tx.Commit()
		return nil
	}

	cmd := `INSERT INTO replies(thread_id, comment, time) VALUES ($1, $2, CURRENT_TIMESTAMP)`
	res, err := tx.Exec(cmd, reply.Thread_id, reply.Comment)
	_ = res
	if err != nil {
		log.Println(err)
	}
	tx.Commit()
	return nil
}

func queryAllThreads(db *sqlx.DB) ([]Thread, error) {
	threads := []Thread{}
	err := db.Select(&threads, `SELECT id, title, comment, to_char(time, 'DD/MM/YYYY HH24:MI:SS'), image_id FROM threads`)
	if err != nil {
		fmt.Println(err)
		return threads, err
	}
	return threads, nil
}

func queryThread(db *sqlx.DB, thread_id int64) (Thread, error) {
	thread := Thread{}
	err := db.Get(&thread, `SELECT id,title,comment,to_char(time, 'DD/MM/YYYY HH24:MI:SS'),image_id FROM threads WHERE id=$1`, thread_id)
	if err != nil {
		return thread, err
	}
	return thread, nil
}

func queryThreadReplies(db *sqlx.DB, thread_id int) ([]Reply, error) {
	replies := []Reply{}
	rows, err := db.Queryx(`SELECT comment, to_char(time, 'DD/MM/YYYY HH24:MI:SS'), image_id FROM replies WHERE thread_id=$1`, thread_id)
	if err != nil {
		log.Println(err)
	}
	for rows.Next() {
		reply := Reply{}
		err := rows.StructScan(&reply)
		if err != nil {
			return replies, err
		}
		replies = append(replies, reply)
	}
	return replies, nil
}
