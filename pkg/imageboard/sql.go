package imageboard

import (
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/jmoiron/sqlx"
)

type Thread struct {
	Thread_id int
	Title     string `form:"title"`
	Comment   string `form:"comment"`
	Time      string `db:"to_char"`
}

type Reply struct {
	Reply_id  int
	Thread_id int
	Comment   string `form:"comment"`
	Time      string `db:"to_char"`
}

const imagesDir = "../../images/"

func ConnectToDB() *sqlx.DB {
	return sqlx.MustConnect("pgx", os.Getenv("DATABASE_URL"))
}

func InitSchema(db *sqlx.DB) {
	schema := `CREATE TABLE threads (
            id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            image_id uuid REFERENCES images(uuid),
            title varchar(80),
            comment varchar(2000),
            time timestamp
        );

        CREATE TABLE replies(
            id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            thread_id integer REFERENCES threads(id),
            image_id uuid REFERENCES images(uuid),
            comment varchar(2000),
            time timestamp
        );
        CREATE TABLE images(
            id uuid PRIMARY KEY,
            name varchar(255)
        );`

	db.MustExec(schema)
}

func CreateThread(db *sqlx.DB, thread Thread, img *multipart.FileHeader) error {
	tx, err := db.Begin()
	if err != nil {
		log.Println(err.Error())
		return err
	}

	var uuid string
	row := tx.QueryRow(`SELECT gen_random_uuid()`)
	err = row.Scan(&uuid)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	filePath := imagesDir + uuid
	srcFile, err := img.Open()
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}
	dstFile, err := os.Create(filePath)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}
	defer srcFile.Close()
	defer dstFile.Close()
	io.Copy(dstFile, srcFile)

	_, err = tx.Exec(`INSERT INTO images(id, name) VALUES ($1, $2)`, uuid, img.Filename)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	cmd := `INSERT INTO threads(title, comment, time) VALUES ($1,$2, CURRENT_TIMESTAMP)`
	_, err = db.Exec(cmd, thread.Title, thread.Comment)
	if err != nil {
		log.Println(err)
		tx.Rollback()
		return err
	}

	tx.Commit()

	return nil
}

func CreateReply(db *sqlx.DB, reply Reply) {
	cmd := `INSERT INTO replies(thread_id, comment, time) VALUES ($1, $2, CURRENT_TIMESTAMP)`
	res, err := db.Exec(cmd, reply.Thread_id, reply.Comment)
	_ = res
	if err != nil {
		log.Println(err)
	}
}

func queryAllThreads(db *sqlx.DB) ([]Thread, error) {
	threads := []Thread{}
	err := db.Select(&threads, `SELECT thread_id, title, comment, to_char(time, 'DD/MM/YYYY HH24:MI:SS') FROM threads`)
	if err != nil {
		fmt.Println(err)
		return threads, err
	}
	return threads, nil
}

func queryThread(db *sqlx.DB, thread_id int64) (Thread, error) {
	thread := Thread{}
	err := db.Get(&thread, `SELECT thread_id,title,comment,to_char(time, 'DD/MM/YYYY HH24:MI:SS') FROM threads WHERE thread_id=$1`, thread_id)
	if err != nil {
		return thread, err
	}
	return thread, nil
}

func queryThreadReplies(db *sqlx.DB, thread_id int) ([]Reply, error) {
	replies := []Reply{}
	rows, err := db.Queryx(`SELECT comment, to_char(time, 'DD/MM/YYYY HH24:MI:SS') FROM replies WHERE thread_id=$1`, thread_id)
	if err != nil {
		log.Println(err)
	}
	for rows.Next() {
		reply := Reply{}
		err := rows.StructScan(&reply)
		if err != nil {
			return replies, err
		}
		replies = append(replies, reply)
	}
	return replies, nil
}
